\\ QINP Standard Library
\\ Platform Independent implementation



\\ Convenience definitions
define EXIT_SUCCESS 0
define EXIT_FAILURE 1

define char i8
define short i16
define int i32
define long i64

define uchar u8
define ushort u16
define uint u32
define ulong u64

define _FILE i32
define _RESULT i32



space std:
	\\ Returns the smaller of two values
	\\ @param a The first value
	\\ @param b The second value
	\\ @return The smaller of the two values
	\\ TODO: blueprint support
	i64 min(i64 a, i64 b)...
	\\ blueprint T
	\\ T& min(T& a, T& b)...

	\\ Returns the larger of two values
	\\ @param a The first value
	\\ @param b The second value
	\\ @return The larger of the two values
	\\ TODO: blueprint support
	i64 max(i64 a, i64 b)...
	\\ blueprint T
	\\ T& max(T& a, T& b)...

	\\ Returns the absolute value of a value
	\\ @param a The value
	\\ @return The absolute value of the value
	i64 abs(i64 a)...
	\\ blueprint T
	\\ T abs(const T& a)...

	\\ Returns the sign of a value
	\\ @param a The value
	\\ @return The sign of the value
	i64 sign(i64 a)...
	\\ blueprint T
	\\ T sign(const T& a)...

	\\ Returns the value of base raised to the power of exponent.
	\\ @param base The base
	\\ @param exponent The exponent (must be greater than or equal to 0)
	\\ @return The value of base raised to the power of exponent
	i64 pow(i64 base, i64 exponent)...

	\\ Terminate the calling process and return the specified exit status.
	\\ @param status The exit status to return to the parent process.
	void exit(i32 status)...		\\ Platform dependent implementation

	\\ Determine the length of a string (without the null terminator)
	\\ @param str The null-terminated string to measure
	\\ @return The length of the string
	u64 strlen(u8* str)...

	\\ Print a null-terminated string to stdout
	\\ @param str The null-terminated string to print
	\\ @return The number of characters printed. Negative on error.
	_RESULT print(u8* str)...
	\\ blueprint T
	\\ _RESULT print(const T& str)...

	\\ Print a string of specified length to stdout
	\\ @param str The string to print
	\\ @param len The length of the string to print
	\\ @return The number of characters printed. Negative on error.
	_RESULT print(u8* str, u64 len)...		\\ Platform dependent implementation

	\\ Print a base-10 integer to stdout
	\\ @param num The integer to print
	\\ @return The number of characters printed. Negative on error.
	_RESULT print(i64 num)...

	\\ Reads a character from stdin
	\\ @return The character read from stdin
	u8 getchar()...		\\ Platform dependent implementation

	\\ Read a null-terminated string from stdin
	\\ @param dest The destination buffer
	\\ @param size The size of the destination buffer
	\\ @return Address of the destination buffer
	u8* scan(u8* dest, u64 size)...

	\\ Reverse a null-terminated string
	\\ @param str The null-terminated string to reverse
	\\ @return The reversed string
	u8* strrev(u8* str)...

	\\ Reverse a string of specified length
	\\ @param begin Pointer to the first character of the string to reverse
	\\ @param end Pointer to the character after the last character of the string to reverse (usually the null-terminator)
	\\ @return The reversed string
	u8* strrev(u8* begin, u8* end)...

	\\ Copy a null-terminated string
	\\ @param dest The destination buffer
	\\ @param src The source string
	\\ @return The destination buffer
	u8* strcpy(u8* dest, u8* src)...

	\\ Compare two null-terminated strings
	\\ @param str1 The first string
	\\ @param str2 The second string
	\\ @return 0 if the strings are equal, < 0 if str1 is less than str2, > 0 if str1 is greater than str2
	i32 strcmp(u8* str1, u8* str2)...

	\\ Convert an integer to a string
	\\ @param num The integer to convert
	\\ @param str The string to store the converted integer in
	\\ @param base The base to use for the conversion (Valid values are 2 to 36)
	\\ @return The null-terminated string representation of the integer
	u8* itos(i64 num, u8* str, i64 base)...

	\\ Convert a string to a base-10 integer
	\\ @param str The string to convert
	\\ @param base The base to use for the conversion (Valid values are 2 to 36)
	\\ @return The integer represented by the string
	i64 stoi(u8* str, i64 base)...

	\\ Converts a character to uppercase. Values not in the range 'a' to 'z' are unchanged.
	\\ @param c The character to convert
	\\ @return The uppercase character
	u8 toupper(u8 c)...

	\\ Converts a character to lowercase. Values not in the range 'A' to 'Z' are unchanged.
	\\ @param c The character to convert
	\\ @return The lowercase character
	u8 tolower(u8 c)...

	\\ Copy data from one buffer to another
	\\ @param dest The destination buffer
	\\ @param src The source buffer
	\\ @param len The number of bytes to copy
	\\ @return The destination buffer
	void* memcpy(void* dest, void* src, u64 len)...

	\\ Get the arguments passed to the program
	\\ @param pargv Address of the pointer where the pointer of the first argument will be stored
	\\ @return The number of arguments passed to the program
	u64 getargs(u8*** pargv)...

	\\ Get the environment variables passed to the program
	\\ @return The pointer to an array of environment variables
	u8** getenv()...

	\\ Sleep for the specified number of milliseconds
	\\ @param ms The number of milliseconds to sleep
	\\ @return Zero on success, negative on error
	_RESULT sleep(u64 ms)...		\\ Platform dependent implementation

	\\ Control device
	\\ @param fd An open file descriptor
	\\ @param request The request to perform
	\\ @param arg The argument to the request
	\\ @return The result of the request
	_RESULT ioctl(_FILE fd, u32 request, void* parg)...

	\\ Open a file
	\\ @param filename The path to the file to open
	\\ @param flags The flags to use when opening the file
	\\ @param mode The mode to use when opening the file
	\\ @return An open file descriptor
	_FILE open(u8* filename, i32 flags, u16 mode)...



	i64 min(i64 a, i64 b):
		return a < b ? a : b

	i64 max(i64 a, i64 b):
		return a > b ? a : b

	i64 abs(i64 a):
		return a < 0 ? -a : a

	i64 sign(i64 a):
		return a < 0 ? -1 : a > 0 ? --1 : -0
	
	i64 pow(i64 base, i64 exponent):
		i64 result = 1
		while exponent > 0:
			result *= base
			--exponent
		return result

	u64 strlen(u8* str):
		u8* begin = str
		while *str:
			++str
		return str - begin

	_RESULT print(u8* str):
		return print(str, strlen(str))

	_RESULT print(i64 num):
		u8 str[32]
		return print(itos(num, str, 10))

	u8* scan(u8* dest, u64 size):
		if !size:
			return dest
		u8* begin = dest

		while --size:
			*dest++ = getchar()

		*dest = '\0'
		return begin

	u8* strrev(u8* str):
		return strrev(str, str + strlen(str))

	u8* strrev(u8* begin, u8* end):
		u8* str = begin
		u8 temp

		while begin < end:
			temp = *begin
			*begin++ = *--end
			*end = temp

		return str

	u8* strcpy(u8* dest, u8* src):
		u8* begin = dest
		while *src:
			*dest++ = *src++
		*dest = '\0'
		return begin
	
	i32 strcmp(u8* str1, u8* str2):
		while *str1 && *str2:
			if *str1 != *str2:
				break
			++str1
			++str2
		return (i32)*str1 - (i32)*str2

	u8* itos(i64 num, u8* str, i64 base):
		u8* baseChars = "0123456789abcdefghijklmnopqrstuvwxyz"

		u8* begin = str
		bool negative = num < 0

		if negative:
			num *= -1

		do:
			*str++ = baseChars[num % base]
			num /= base
		while num

		if negative:
			*str++ = '-'

		*str = '\0'

		return strrev(begin, str)

	i64 stoi(u8* str, i64 base):
		u8* baseChars = "0123456789abcdefghijklmnopqrstuvwxyz"

		i64 num = 0
		bool negative = *str == '-'
		if negative:
			++str

		while *str:
			u8 ch = tolower(*str++)
			i64 index = 0
			while baseChars[index] != ch:
				++index
			num = num * base + index

		if negative:
			num = -num

		return num

	u8 toupper(u8 c):
		if c < 'a' || c > 'z':
			return c
		return c - 'a' + 'A'

	u8 tolower(u8 c):
		if c < 'A' || c > 'Z':
			return c
		return c - 'A' + 'a'

	void* memcpy(void* dest, void* src, u64 len):
		u8* d = (u8*)dest
		u8* s = (u8*)src

		while len--:
			*d++ = *s++
		return dest

	u64 getargs(u8*** pargv):
		u64 argc
		assembly:
			"mov rcx, [__##__argc]"
			"mov [rbp $(argc)], rcx"

		if !pargv:
			return argc

		u8** argv
		assembly:
			"mov rcx, [__##__argv]"
			"mov [rbp $(argv)], rcx"

		*pargv = argv

		return argc

	u8** getenv():
		u8** env
		assembly:
			"mov rcx, [__##__envp]"
			"mov [rbp $(env)], rcx"

		return env

import.linux "linux/std.qnp"
import.windows "windows/std.qnp"