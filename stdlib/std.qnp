\\ QINP Standard library main header


import "linux.qnp"


\\ Convenience definitions
define EXIT_SUCCESS 0
define EXIT_FAILURE 1

define char i8
define short i16
define int i32
define long i64

define uchar u8
define ushort u16
define uint u32
define ulong u64

define _FILE i32
define _RESULT i32

space std:
	u8 buff[10]


space std:
	\\ Terminate the calling process and return the specified exit status.
	\\ @param status The exit status to return to the parent process.
	void exit(i32 status)...

	\\ Determine the length of a string (without the null terminator)
	\\ @param str The null-terminated string to measure
	\\ @return The length of the string
	u64 strlen(u8* str)...

	\\ Print a null-terminated string to stdout
	\\ @param str The null-terminated string to print
	_RESULT print(u8* str)...

	\\ Print a string of specified length to stdout
	\\ @param str The string to print
	\\ @param len The length of the string to print
	_RESULT print(u8* str, u64 len)...

	\\ Print a base-10 integer to stdout
	\\ @param num The integer to print
	_RESULT print(i64 num)...

	\\ Reads a character from stdin
	\\ @return The character read from stdin
	u8 getchar()...

	\\ Read a null-terminated string from stdin
	\\ @param dest The destination buffer
	\\ @param size The size of the destination buffer
	u8* scan(u8* dest, u64 size)...

	\\ Reverse a null-terminated string
	\\ @param str The null-terminated string to reverse
	\\ @return The reversed string
	u8* strrev(u8* str)...

	\\ Reverse a string of specified length
	\\ @param begin Pointer to the first character of the string to reverse
	\\ @param end Pointer to the character after the last character of the string to reverse (usually the null-terminator)
	\\ @return The reversed string
	u8* strrev(u8* begin, u8* end)...

	\\ Copy a null-terminated string
	\\ @param dest The destination buffer
	\\ @param src The source string
	\\ @return The destination buffer
	u8* strcpy(u8* dest, u8* src)...

	\\ Compare two null-terminated strings
	\\ @param str1 The first string
	\\ @param str2 The second string
	\\ @return 0 if the strings are equal, < 0 if str1 is less than str2, > 0 if str1 is greater than str2
	i32 strcmp(u8* str1, u8* str2)...

	\\ Convert an integer to a string
	\\ @param num The integer to convert
	\\ @param str The string to store the converted integer in
	\\ @param base The base to use for the conversion (Valid values are 2 to 36)
	\\ @return The null-terminated string representation of the integer
	u8* itos(i64 num, u8* str, i64 base)...

	\\ Convert a string to a base-10 integer
	\\ @param str The string to convert
	\\ @param base The base to use for the conversion (Valid values are 2 to 36)
	\\ @return The integer represented by the string
	i64 stoi(u8* str, i64 base)...

	\\ Converts a character to uppercase. Values not in the range 'a' to 'z' are unchanged.
	\\ @param c The character to convert
	\\ @return The uppercase character
	u8 toupper(u8 c)...

	\\ Converts a character to lowercase. Values not in the range 'A' to 'Z' are unchanged.
	\\ @param c The character to convert
	\\ @return The lowercase character
	u8 tolower(u8 c)...

	\\ Copy data from one buffer to another
	\\ @param dest The destination buffer
	\\ @param src The source buffer
	\\ @param len The number of bytes to copy
	void* memcpy(void* dest, void* src, u64 len)...

	\\ Get the arguments passed to the program
	\\ @param pargv Address of the pointer where the pointer of the first argument will be stored
	\\ @return The number of arguments passed to the program
	u64 getargs(u8*** pargv)...

	\\ Get the environment variables passed to the program
	\\ @return The pointer to an array of environment variables
	u8** getenv()...

	\\ Pack holding a time specified in seconds and nanoseconds
	pack __timespec...

	\\ Sleep for the specified number of milliseconds
	\\ @param ms The number of milliseconds to sleep
	_RESULT sleep(u64 ms)...

	\\ Control device
	\\ @param fd An open file descriptor
	\\ @param request The request to perform
	\\ @param arg The argument to the request
	\\ @return The result of the request
	_RESULT ioctl(_FILE fd, u32 request, void* parg)...

	\\ Open a file
	\\ @param filename The path to the file to open
	\\ @param flags The flags to use when opening the file
	\\ @param mode The mode to use when opening the file
	\\ @return An open file descriptor
	_FILE open(u8* filename, i32 flags, u16 mode)...



	void exit(i32 status):
		assembly:
			"mov rax, $(SYS_EXIT)"
			"mov edi, [rbp $(status)]"
			"syscall"

	u64 strlen(u8* str):
		u8* begin = str
		while *str:
			++str
		return str - begin

	_RESULT print(u8* str):
		return print(str, strlen(str))

	_RESULT print(u8* str, u64 len):
		_RESULT result
		assembly:
			"mov rax, $(SYS_WRITE)"
			"mov rdi, 1"
			"mov rsi, [rbp $(str)]"
			"mov rdx, [rbp $(len)]"
			"syscall"
			"mov [rbp $(result)], eax"
		return result

	_RESULT print(i64 num):
		u8 str[32]
		return print(itos(num, str, 10))

	u8 getchar():
		u8 ch

		assembly:
			"mov rax, $(SYS_READ)"
			"mov rdi, 0"
			"mov rsi, rbp"
			"add rsi, $(ch)"
			"mov rdx, 1"
			"syscall"

		return ch

	u8* scan(u8* dest, u64 size):
		if !size:
			return dest
		u8* begin = dest

		while --size:
			*dest++ = getchar()

		*dest = '\0'
		return begin

	u8* strrev(u8* str):
		return strrev(str, str + strlen(str))

	u8* strrev(u8* begin, u8* end):
		u8* str = begin
		u8 temp

		while begin < end:
			temp = *begin
			*begin++ = *--end
			*end = temp

		return str

	u8* strcpy(u8* dest, u8* src):
		u8* begin = dest
		while *src:
			*dest++ = *src++
		*dest = '\0'
		return begin
	
	i32 strcmp(u8* str1, u8* str2):
		while *str1 && *str2:
			if *str1 != *str2:
				break
			++str1
			++str2
		return (i32)*str1 - (i32)*str2

	u8* itos(i64 num, u8* str, i64 base):
		u8* baseChars = "0123456789abcdefghijklmnopqrstuvwxyz"

		u8* begin = str
		bool negative = num < 0

		if negative:
			num = -num

		do:
			*str++ = baseChars[num % base]
			num = num / base
		while num

		if negative:
			*str++ = '-'

		*str = '\0'

		return strrev(begin, str)

	i64 stoi(u8* str, i64 base):
		u8* baseChars = "0123456789abcdefghijklmnopqrstuvwxyz"

		i64 num = 0
		bool negative = *str == '-'
		if negative:
			++str

		while *str:
			u8 ch = *str++
			i64 index = 0
			while baseChars[index] != ch:
				++index
			num = num * base + index

		if negative:
			num = -num

		return num

	u8 toupper(u8 c):
		if c < 'a' || c > 'z':
			return c
		return c - 'a' + 'A'

	u8 tolower(u8 c):
		if c < 'A' || c > 'Z':
			return c
		return c - 'A' + 'a'

	void* memcpy(void* dest, void* src, u64 len):
		u8* d = (u8*)dest
		u8* s = (u8*)src

		while len--:
			*d++ = *s++
		return dest

	u64 getargs(u8*** pargv):
		u64 argc
		assembly:
			"mov rcx, [__##__argc]"
			"mov [rbp $(argc)], rcx"

		if !pargv:
			return argc

		u8** argv
		assembly:
			"mov rcx, [__##__argv]"
			"mov [rbp $(argv)], rcx"

		*pargv = argv

		return argc

	u8** getenv():
		u8** env
		assembly:
			"mov rcx, [__##__envp]"
			"mov [rbp $(env)], rcx"

		return env

	pack __timespec:
		i64 seconds
		i64 nanoseconds

	_RESULT sleep(u64 ms):
		__timespec ts
		ts.seconds = ms / 1000
		ts.nanoseconds = (ms % 1000) * 1000000
		_RESULT result
		assembly:
			"mov rax, $(SYS_NANOSLEEP)"
			"mov rdi, rbp"
			"add rdi, $(ts)"
			"xor rsi, rsi"
			"syscall"
			"mov [rbp $(result)], eax"
		return result

	_RESULT ioctl(_FILE fd, u32 request, void* parg):
		_RESULT result
		assembly:
			"mov rax, $(SYS_IOCTL)"
			"mov edi, [rbp $(fd)]"
			"mov esi, [rbp $(request)]"
			"mov rdx, [rbp $(parg)]"
			"syscall"
			"mov [rbp $(result)], eax"
		return result

	_FILE open(u8* filename, i32 flags, u16 mode):
		_RESULT result
		assembly:
			"mov rax, $(SYS_OPEN)"
			"mov rdi, [rbp $(filename)]"
			"mov esi, [rbp $(flags)]"
			"mov edx, [rbp $(mode)]"
			"syscall"
			"mov [rbp $(result)], eax"
		return result