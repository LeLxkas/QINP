\\ QINP Standard Library
\\ Memory - Linux Specific

import "syscall.qnp"

space std:
	define PAGE_SIZE 4096

	\\ Changes the data segment size to the given size and returns the new size.
	\\ @param size The new size
	\\ @return The size after the change (Current size on failure)
	u64 __brk(u64 size):
		u64 result
		assembly:
			"mov rax, $(SYS_BRK)"
			"mov rdi, [rbp $(size)]"
			"syscall"
			"mov [rbp $(result)], rax"
		return result

	\\ Changes the data segment size by the given amount and returns a pointer to the newly allocated memory.
	\\ @param increment The amount to increase the data segment size by
	\\ @return A pointer to the newly allocated memory (null on failure)
	void* __sbrk(u64 increment):
		u64 currSize = __brk(0)
		u64 newSize = currSize + increment
		if __brk(newSize) == currSize:
			return null
		return (void*)currSize

	\\ The header for every allocated block of memory (used for freeing/keeping track of allocated, unused memory)
	pack __MemBlockHeader:
		__MemBlockHeader* prev
		__MemBlockHeader* next
		u64 sizeAvail

	\\ First node in the list of allocated data blocks sorted by address
	__MemBlockHeader* __memBlocks = null

	\\ Returns the smallest block of memory that is large enough to hold the given size.
	\\ @param sizeAvail The available size of the block to find
	\\ @return The smallest block of memory that is large enough to hold the given size (null on failure)
	__MemBlockHeader* __getAvailBlock(u64 sizeAvail):
		__MemBlockHeader* smallest = null
		__MemBlockHeader* curr = __memBlocks
		while curr != null:
			if curr->sizeAvail >= sizeAvail:
				if smallest == null || curr->sizeAvail < smallest->sizeAvail:
					smallest = curr
			curr = curr->next
		return smallest

	\\ Inserts a new block of memory into the list of free blocks at the correct location.
	\\ @param block The block of memory to insert
	void __insertAvailBlock(__MemBlockHeader* block):
		__MemBlockHeader* prev = null
		__MemBlockHeader* curr = __memBlocks
		while curr != null:
			if block < curr:
				break
			prev = curr
			curr = curr->next
		block->prev = prev
		block->next = curr
		if prev != null:
			prev->next = block
		if curr != null:
			curr->prev = block
		
		if curr == __memBlocks:
			__memBlocks = block

	\\ Removes a block of memory from the list of free blocks.
	\\ @param block The block of memory to remove
	void __removeAvailBlock(__MemBlockHeader* block):
		if block->prev != null:
			block->prev->next = block->next
		if block->next != null:
			block->next->prev = block->prev
		if block == __memBlocks:
			__memBlocks = block->next

	\\ Shrinks the given block of memory to the given available size.
	\\ Does not change the size of the block if it is already smaller.
	\\ @param block The block of memory to shrink
	\\ @param newSizeAvail The new available size of the block
	void __shrinkBlock(__MemBlockHeader* block, u64 newSizeAvail):
		if block->sizeAvail + sizeof(__MemBlockHeader) < newSizeAvail:
			return

		__MemBlockHeader* newBlock = (__MemBlockHeader*)((u64)block + sizeof(__MemBlockHeader) + newSizeAvail)
		newBlock->sizeAvail = block->sizeAvail - newSizeAvail - sizeof(__MemBlockHeader)
		block->sizeAvail = newSizeAvail

		__insertAvailBlock(newBlock)

	\\ Merges the given blocks of memory into a single block.
	\\ Both blocks must be adjacent.
	\\ @param block1 The first block of memory to merge
	\\ @param block2 The second block of memory to merge
	void __mergeBlocks(__MemBlockHeader* block1, __MemBlockHeader* block2):
		block1->sizeAvail += sizeof(__MemBlockHeader) + block2->sizeAvail
		block1->next = block2->next
		if block2->next != null:
			block2->next->prev = block1

	\\ Merges the given block with the previous and next blocks if they are adjacent.
	\\ @param block The block of memory to merge
	void __mergeBlockWithNeighbors(__MemBlockHeader* block):
		if block->prev != null && (u64)block->prev + block->prev->sizeAvail + sizeof(__MemBlockHeader) == (u64)block:
			block = block->prev
			__mergeBlocks(block, block->next)
		if block->next != null && (u64)block + block->sizeAvail + sizeof(__MemBlockHeader) == (u64)block->next:
			__mergeBlocks(block, block->next)

	\\ Allocates a block of memory padded to a page size while being big enough to hold the given available size and the block header.
	\\ @param sizeAvail The size of the block to allocate
	\\ @return A pointer to the header of the allocated block (null on failure)
	__MemBlockHeader* __allocBlock(u64 sizeAvail):
		u64 size = sizeAvail + sizeof(__MemBlockHeader)
		size = size + PAGE_SIZE - (size % PAGE_SIZE)
		__MemBlockHeader* block = (__MemBlockHeader*)__sbrk(size)
		if block == null:
			return null

		block->sizeAvail = size - sizeof(__MemBlockHeader)
		
		return block

	void* malloc(u64 size)!:
		if size == 0:
			return null

		__MemBlockHeader* block = __getAvailBlock(size)
		if block != null:
			__removeAvailBlock(block)
		else:
			block = __allocBlock(size)

		if block == null:
			return null

		__shrinkBlock(block, size)
		return block + 1

	void free(void* ptr)!:
		if ptr == null:
			return
			
		__MemBlockHeader* block = (__MemBlockHeader*)ptr - 1
		__insertAvailBlock(block)
		__mergeBlockWithNeighbors(block)
