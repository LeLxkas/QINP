\\ QINP Standard Library
\\ Memory - Linux Specific

import "syscall.qnp"

space std:
	define __PAGE_SIZE 4096
	define __FREE_PAGES_COUNT_MAX 256
	define __MEM_ALIGNMENT_SIZE 8

	\\ Changes the data segment size to the given size and returns the new size.
	\\ @param size The new size
	\\ @return The size after the change (Current size on failure)
	u64 __brk(u64 size):
		u64 result
		assembly:
			"mov rax, $(SYS_BRK)"
			"mov rdi, [rbp $(size)]"
			"syscall"
			"mov [rbp $(result)], rax"
		return result

	\\ Changes the data segment size by the given amount and returns a pointer to the newly allocated memory.
	\\ @param increment The amount to increase the data segment size by
	\\ @return A pointer pointing to the previous data segment end (null on failure)
	void* __sbrk(i64 increment):
		u64 oldSize = __brk(0)
		u64 newSize = oldSize + increment
		return __brk(newSize) == oldSize ? (void*)null : (void*)oldSize

	\\ The header for every allocated block of memory (used for freeing/keeping track of allocated, unused memory)
	pack __MemBlockHeader:
		__MemBlockHeader* prev
		__MemBlockHeader* next
		u64 sizeAvail

	\\ First node in the list of allocated data blocks sorted by address
	__MemBlockHeader* __memBlocks = null

	\\ Rounds the given value up to the nearest multiple of the given alignment
	\\ @param value The value to round
	\\ @param alignment The alignment to round to
	\\ @return The rounded value
	u64 __roundUp(u64 value, u64 alignment):
		return ((value + alignment - 1) / alignment) * alignment

	\\ Rounds the given value down to the nearest multiple of the given alignment
	\\ @param value The value to round
	\\ @param alignment The alignment to round to
	\\ @return The rounded value
	u64 __roundDown(u64 value, u64 alignment):
		return (value / alignment) * alignment

	\\ Returns the smallest block of memory that is large enough to hold the given size.
	\\ If no block is large enough, returns the last block in the list.
	\\ @param sizeAvail The available size of the block to find
	\\ @return The smallest block of memory that is large enough to hold the given size or the last block in the list
	__MemBlockHeader* __getAvailBlock(u64 sizeAvail):
		\\ No check for sizeAvail == 0 because a block may have 0 bytes of available space
		__MemBlockHeader* smallest = null
		__MemBlockHeader* last = null
		__MemBlockHeader* curr = __memBlocks

		while curr != null:
			if curr->sizeAvail >= sizeAvail:
				if smallest == null || curr->sizeAvail < smallest->sizeAvail:
					smallest = curr
			last = curr
			curr = curr->next
		return smallest != null ? smallest : last

	\\ Inserts a new block of memory into the list (sorted by address)
	\\ @param block The block of memory to insert
	\\ @return The block before the inserted block (null if the block was inserted at the beginning of the list)
	__MemBlockHeader* __insertAvailBlock(__MemBlockHeader* block):
		if block == null: return null

		__MemBlockHeader* prev = null
		__MemBlockHeader* curr = __memBlocks

		while curr != null && block >= curr:
			prev = curr
			curr = curr->next

		block->prev = prev
		block->next = curr

		if prev != null: prev->next = block
		if curr != null: curr->prev = block
		
		if curr == __memBlocks: __memBlocks = block

		return prev

	\\ Removes a block of memory from the list of free blocks.
	\\ @param block The block of memory to remove
	void __removeAvailBlock(__MemBlockHeader* block):
		if block == null: return
		if block == __memBlocks: __memBlocks = block->next
		
		if block->prev != null: block->prev->next = block->next
		if block->next != null: block->next->prev = block->prev

		block->prev = null
		block->next = null

	\\ Splits the given block of memory into two. The first block gets the given size (and a possible padding for alignment) and the second block gets the remaining size.
	\\ If the new block would have an available size of 0 or less, the block is not split and null is returned.
	\\ The new block is always aligned to __MEM_ALIGNMENT_SIZE.
	\\ @param block The block of memory to shrink
	\\ @param newSizeAvail The new available size of the block
	\\ @return The new block of memory (null if the block was not split)
	__MemBlockHeader* __splitBlock(__MemBlockHeader* block, u64 newSizeAvail):
		if block == null || newSizeAvail == 0: return null

		newSizeAvail = __roundUp(newSizeAvail, __MEM_ALIGNMENT_SIZE)
		if block->sizeAvail + sizeof(__MemBlockHeader) < newSizeAvail:
			return null

		__MemBlockHeader* newBlock = (__MemBlockHeader*)((u64)block + sizeof(__MemBlockHeader) + newSizeAvail)
		newBlock->sizeAvail = block->sizeAvail - newSizeAvail - sizeof(__MemBlockHeader)
		block->sizeAvail = newSizeAvail

		return newBlock

	\\ Merges the given blocks of memory into a single block.
	\\ Both blocks must be adjacent.
	\\ @param block1 The first block of memory to merge
	\\ @param block2 The second block of memory to merge
	\\ @return The merged block of memory
	__MemBlockHeader* __mergeBlocks(__MemBlockHeader* block1, __MemBlockHeader* block2):
		if block1 == null || block2 == null: return null

		block1->sizeAvail += sizeof(__MemBlockHeader) + block2->sizeAvail
		block1->next = block2->next
		if block2->next != null: block2->next->prev = block1

		return block1

	\\ Checks whether the given block of memory is adjacent to the next one.
	\\ @param block The block of memory to check
	\\ @return True if the block is adjacent to the next one, otherwise false
	bool __isAdjacentToNext(__MemBlockHeader* block):
		if block == null || block->next == null: return false

		return (u64)block + sizeof(__MemBlockHeader) + block->sizeAvail == (u64)block->next

	\\ Merges the given block with the previous and next blocks if they are adjacent.
	\\ @param block The block of memory to merge
	\\ @return Pointer to the merged block
	__MemBlockHeader* __mergeBlockWithNeighbors(__MemBlockHeader* block):
		if block == null: return null

		if __isAdjacentToNext(block->prev):
			block = __mergeBlocks(block->prev, block)
		if __isAdjacentToNext(block):
			block = __mergeBlocks(block, block->next)

		return block

	\\ Allocates a block of memory padded to a page size while being big enough to hold the given available size and the block header.
	\\ @param sizeAvail The size of the block to allocate
	\\ @return A pointer to the header of the allocated block (null on failure)
	__MemBlockHeader* __allocBlock(u64 sizeAvail):
		if sizeAvail == 0: return null

		u64 size = __roundUp(sizeAvail + sizeof(__MemBlockHeader), __PAGE_SIZE)
		__MemBlockHeader* block = (__MemBlockHeader*)__sbrk(size)
		if block == null: return null

		block->sizeAvail = size - sizeof(__MemBlockHeader)
		
		return block

	void* malloc(u64 size)!:
		if size == 0: return null

		__MemBlockHeader* block = __getAvailBlock(size)
		if block != null:
			if block->sizeAvail < size: \\ Expand the last block if it is not big enough
				u64 newAllocatedSize = __roundUp(size - block->sizeAvail, __PAGE_SIZE)
				if __sbrk(newAllocatedSize) == null: return null
				block->sizeAvail += newAllocatedSize
			__removeAvailBlock(block)
		else:
			block = __allocBlock(size)

		if block == null: return null

		__MemBlockHeader* newBlock = __splitBlock(block, size)
		if newBlock != null: __insertAvailBlock(newBlock)

		return block + 1

	void free(void* ptr)!:
		if ptr == null: return

		__MemBlockHeader* block = (__MemBlockHeader*)ptr - 1
		__insertAvailBlock(block)
		block = __mergeBlockWithNeighbors(block)

		if block->next == null: \\ Block is the last one in the list
			u64 size = block->sizeAvail
			if size > __PAGE_SIZE * __FREE_PAGES_COUNT_MAX: \\ Block is big enough to be freed
				size = __roundDown(size, __PAGE_SIZE)
				__sbrk(-size)
				block->sizeAvail -= size
